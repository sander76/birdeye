"""
A full screen file tree viewer using prompt_toolkit.
Navigate with arrow keys, expand/collapse with Enter or Space.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Generator, Iterable, Literal, Optional, Self, Tuple

import pygit2
from prompt_toolkit.data_structures import Point
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.layout.containers import Window
from prompt_toolkit.layout.controls import FormattedTextControl
from prompt_toolkit.layout.scrollable_pane import ScrollablePane
from prompt_toolkit.styles import Style

_logger = logging.getLogger(__name__)


@dataclass
class Settings:
    root_folder: Path
    use_git_ignore: bool = True

def use_gitignore(
    repo: pygit2.Repository, root_folder: Path
) -> Generator[Path, None, None]:
    """check whether any child inside the root_folder is being git-ignored."""

    as_path = Path(repo.workdir)

    for child in root_folder.iterdir():
        rel_path = str(child.relative_to(as_path))
        if repo.path_is_ignored(rel_path):
            continue
        yield child


class BaseNode:
    """Base class for all node types with common comparison functionality."""

    def __init__(self, path: Path, level: int):
        self.path = path
        self.name = path.name
        self.focussed: bool = False
        self._level = level

    def __lt__(self, other) -> bool:
        """Enable sorting by name property."""
        return self.name < other.name

    def __le__(self, other) -> bool:
        """Enable less than or equal comparison."""
        return self.name <= other.name

    def __gt__(self, other) -> bool:
        """Enable greater than comparison."""
        return self.name > other.name

    def __ge__(self, other) -> bool:
        """Enable greater than or equal comparison."""
        return self.name >= other.name

    def __ne__(self, other) -> bool:
        """Enable not equal comparison."""
        return not self.name == other.name

    def _get_style(self) -> str:
        if self.focussed:
            return "bg:#ffffff fg:#000000"
        return ""

    def set_expanded(self, value: bool) -> None:
        raise NotImplementedError

    def render(self) -> tuple[str, str]:
        res = self._get_style(), f"{' ' * self._level} {self._ICON} {self.name}\n"
        # _logger.debug(f"Render a node: {res}")

        return res


class Node(BaseNode):
    _ICON = "ðŸ“„"

    def __init__(self, path: Path, *, parent: TreeNode, level: int) -> None:
        super().__init__(path, level=level)
        self.parent = parent

    def full_tree(self) -> Generator[Node, None, None]:
        yield self

    def focus(self, direction: Literal[-1, 1]) -> Node | TreeNode:
        self.focussed = False
        new_focussed = self.parent.focus(direction=direction)
        return new_focussed

    def __repr__(self) -> str:
        return f"{self.name=!r} {self.focussed=!r}"

    def set_expanded(self, value: bool):
        pass


class TreeNode(BaseNode):
    """Represents a node in the file tree."""

    _ICON = "ðŸ“‚"
    _children: tuple[TreeNode | Node, ...] | None = None

    def __init__(
        self,
        path: Path,
        *,
        parent: TreeNode | None,
        level: int,
        # expanded: bool = False,
        use_gitignore: bool = True,
        git_repo: pygit2.Repository | None,
    ):
        super().__init__(path, level=level)
        self._level = level
        self.parent = parent

        self._expanded: bool = True if parent is None else False

        # index of collection of this node and its children.
        self._focussed_idx: int | None = 0 if parent is None else None

        self.use_gitignore = use_gitignore

        self._git_repo = git_repo

    def __repr__(self) -> str:
        return f"{self.name=!r} {self.parent=!r} {self._expanded=!r} {self._focussed_idx=!r}"

    def set_expanded(self, value: bool):
        self._expanded = value

    def focus(self, direction: Literal[-1, 1] | Node):
        """Focus this or child nodes."""

        # state:
        # focussed, 1,
        _logger.debug(f"setting new focus {direction=!r}")
        _all = self.nodes()

        if self.focussed:
            self._focussed_idx = 0

        match direction, self.parent, self._focussed_idx:
            case -1, None, 0:
                new_idx = 0
                new_focussed = self
            case -1, TreeNode(), 0:
                new_idx = None
                new_focussed = self.parent.focus(-1)
            case -1, _, idx if idx > 0:
                new_idx = self._focussed_idx - 1
                new_focussed = _all[new_idx]

            case 1, None, idx if idx == len(_all) - 1:
                # no parent. staying where we are.
                new_idx = self._focussed_idx
                new_focussed = _all[new_idx]
            case 1, TreeNode(), idx if idx == len(_all) - 1:
                new_idx = None
                new_focussed = self.parent.focus(1)
            case 1, _, _:
                new_idx = self._focussed_idx + 1
                new_focussed = _all[new_idx]
            case _, _, _:
                raise ValueError("fallhrough")

        self.focussed = False
        self._focussed_idx = new_idx

        new_focussed.focussed = True
        _logger.debug(f"focussed name={new_focussed.name}")
        return new_focussed

    @property
    def expanded(self) -> bool:
        return self._expanded

    @expanded.setter
    def expanded(self, value: bool) -> None:
        if value is self._expanded:
            return
        self._expanded = value

    # def render(self) -> tuple[str, str]:
    #     _logger.debug("Render a treenode")
    #     return self._get_style(), f"{self._ICON} {self.name}\n"

    @property
    def children(self) -> tuple[TreeNode | Node, ...]:
        """Load child nodes if this is a directory."""
        if self._children is None:
            if self._git_repo and self.use_gitignore:
                children = use_gitignore(self._git_repo, self.path)
            else:
                children = self.path.iterdir()

            def get_children() -> Generator[TreeNode | Node, None, None]:
                for child in children:
                    if child.is_dir():
                        yield TreeNode(
                            child,
                            parent=self,
                            level=self._level + 1,
                            use_gitignore=self.use_gitignore,
                            git_repo=self._git_repo,
                        )
                    else:
                        yield Node(child, parent=self, level=self._level + 1)

            self._children = tuple(sorted(get_children()))
        return self._children

    def nodes(self) -> tuple[Node | TreeNode, ...]:
        if self.expanded:
            return (self, *self.children)
        return (self,)

    def full_tree(self) -> Generator[Node | TreeNode, None, None]:
        yield self
        if self.expanded:
            for child in self.children:
                yield from child.full_tree()


class FileTreeViewer:
    """Main application class for the file tree viewer."""

    def __init__(self, settings: Settings):
        self.root_path = settings.root_folder.resolve()
        self._settings = settings
        self._root_node = self._selected_node = self._init_root_node()

        text_control = FormattedTextControl(
            text=self._update_display,
            focusable=True,
            key_bindings=self._setup_key_bindings(),
        )

        # self._window = Window(content=text_control, wrap_lines=False)
        self._window = ScrollablePane(Window(content=text_control, wrap_lines=True))

    def __pt_container__(self) -> Window:
        return self._window

    def _init_root_node(self) -> TreeNode:
        _logger.debug("init root")
        if (self.root_path / ".git").exists():
            repository = pygit2.Repository(self.root_path)
        else:
            repository = None

        root_node = TreeNode(
            self.root_path,
            parent=None,
            level=0,
            use_gitignore=self._settings.use_git_ignore,
            git_repo=repository,
        )
        return root_node

    def _setup_key_bindings(self) -> KeyBindings:
        """Setup key bindings for navigation."""
        kb = KeyBindings()

        @kb.add("up")
        def move_up(event):
            self._selected_node = self._selected_node.focus(-1)

        @kb.add("down")
        def move_down(event):
            self._selected_node = self._selected_node.focus(1)

        # @kb.add("enter")
        # def select_and_exit(event):
        #     if self.visible_nodes:
        #         node = self.visible_nodes[self.selected_index]
        #         event.app.exit(str(node.path))

        # @kb.add("space")
        # def toggle_node(event):
        #     if self.visible_nodes:
        #         node = self.visible_nodes[self.selected_index]
        #         node.toggle_expanded()

        @kb.add("right")
        def expand_node(event):
            self._selected_node.set_expanded(value=True)

        @kb.add("left")
        def collapse_node(event):
            self._selected_node.set_expanded(value=False)

        # @kb.add("left")
        # def collapse_node(event):
        #     if self.selected_index < len(self.visible_nodes):
        #         node = self.visible_nodes[self.selected_index]
        #         if node.is_directory and node.expanded:
        #             node.toggle_expanded()
        #         elif node.parent:
        #             # Move to parent
        #             parent_index = self.visible_nodes.index(node.parent)
        #             self.selected_index = parent_index

        @kb.add("q")
        @kb.add("c-c")
        def quit_app(event):
            event.app.exit()

        # @kb.add("r")
        # def refresh(event):
        #     self._refresh_tree()

        return kb

    # def _refresh_tree(self):
    #     """Refresh the entire tree."""

    #     expanded_paths = set(FileTreeViewer._collect_expanded_paths(self.root_node))

    #     self.root_node = self._init_root_node()

    #     self._restore_expanded_state(self.root_node, expanded_paths)

    #     self.selected_index = 0

    # @staticmethod
    # def _collect_expanded_paths(node: TreeNode) -> Iterable[Path]:
    #     """Collect all expanded paths for restoration after refresh."""
    #     if node.expanded:
    #         yield node.path
    #     for child in node.children:
    #         yield from FileTreeViewer._collect_expanded_paths(child)

    # def _restore_expanded_state(self, node: TreeNode, expanded_paths: set[Path]):
    #     """Restore expanded state after refresh."""
    #     if node.path in expanded_paths:
    #         node.expanded = True
    #         node.load_children()
    #         for child in node.children:
    #             self._restore_expanded_state(child, expanded_paths)

    # def _collect_visible_full_tree(
    #     self, node: TreeNode, depth: int = 0
    # ) -> Generator[TreeNode, None, None]:
    #     """Collect all visible nodes for display."""

    #     yield node

    #     if node.expanded:
    #         for child in node.children:
    #             yield from self._collect_visible_full_tree(child, depth + 1)

    # def _get_node_depth(self, node: TreeNode) -> int:
    #     """Get the depth of a node in the tree."""
    #     depth = 0
    #     current = node.parent
    #     while current:
    #         depth += 1
    #         current = current.parent
    #     return depth

    # def _format_node(self, node: TreeNode, is_selected: bool) -> Tuple[str, str]:
    #     """Format a node for display, returning (text, style)."""
    #     depth = self._get_node_depth(node)
    #     indent = "  " * depth

    #     if node.is_directory:
    #         if node.expanded:
    #             icon = "ðŸ“‚ "
    #         else:
    #             icon = "ðŸ“ "
    #     else:
    #         icon = "ðŸ“„ "

    #     name = node.get_name()
    #     line = f"{indent}{icon}{name}"

    #     if is_selected:
    #         line = f"> {line}"
    #         return (line, "selected")
    #     else:
    #         line = f"  {line}"
    #         return (line, "")

    def _update_display(self) -> FormattedText:
        """Update the display buffer with current tree state."""

        # nodes = list((node.render() for node in self._root_node.full_tree()))

        def render() -> Generator[tuple[str, str], None, None]:
            for node in self._root_node.full_tree():
                if node.focussed:
                    yield ("[SetCursorPosition]", "")
                yield node.render()

        nodes = (node for node in render())

        _logger.debug(nodes)
        # # Ensure selected index is valid
        # if self.selected_index >= len(self.visible_nodes):
        #     self.selected_index = len(self.visible_nodes) - 1
        # if self.selected_index < 0:
        #     self.selected_index = 0

        # formatted_content = []

        # for i, node in enumerate(self.visible_nodes):
        #     is_selected = i == self.selected_index
        #     text, style_class = self._format_node(node, is_selected)
        #     if style_class:
        #         formatted_content.append((f"class:{style_class}", text))
        #     else:
        #         formatted_content.append(("", text))
        #     formatted_content.append(("", "\n"))

        return FormattedText(nodes)
